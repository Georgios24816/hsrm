sem mutex=1;empty=N;full=0; erzeuger(){int item;while(1){prodItem(&item);P(&empty); P(&mutex);enterItem(item);V(&mutex);V(&full)}} verbraucher(){int item;while(1){P(&full);P(&mutex);removItem(&item);V(&mutex);V(&empty);consumeItem(item)}}

N=100;MSIZE=4;typedef int message[MSIZE]; producer(){int item;message m;while(1){prodItem(&item);receive(consumer,&m);buildMsg(&m,item);send(consumer,&m)}} consumer
(){int item,i;message m; for i in range(N){send(producer,&m)};while(1 {receive (producer,&m);extractItem(&m,&item);send(producer,&m);consItem(item)}}

Verweilzeit=Abschlusszeit-Ankunftszeit;Q->0;c=0: Processor Sharing
Q->0;c!=0:nur Kontextwechsel;Q->+inf:konvergiert gegen FCFS, RunToCompletion

fork: Kopie des aufrufenden Prozesses, Neuer Prozess(Sohn) mit Kopie der Speicher
inhalte,offenen Dateien usw.,Returnwert: Vater PID des Sohns(Error:-1);Sohn: PID 0
exec: Angegebener Prozess wird geladen,überschreibt laufenden Prozess, erbt seine PID

Verallgemeinterte Bankier Algorithmus: Sachen 3A, 2B, 8C: Personen P1,P2,P3
vorhanden (3 2 8) -> zugewiesen |1 0 2| -> verfügbar (2 0 4) -> angefordert |2 0 2|
				|0 1 1|				      	    |1 1 0|
				|0 1 1|				      	    |3 0 3|
1) P1 verfügbar (3 0 6) ; P3 verfügbar (3 1 7) ; P2 verfügbar (3 2 8)

inode: Block:4KB;12 direkt adressierte Blöcke->48KB;1-, 2-, 3-fach indirekte Blöcke(4KB)
können 2^10 weitere Verweise speichern: maxDateigrösse = (12+2^10+2^20+2^30)*4KB

Deadlock-Vorraussetzung: wechselseitiger Ausschluss (Verfahren, das verhindert dass immer nur ein Prozess auf ein gemeinsames Datum zugreift);
belegungs-/Anforderungsbedingung (Prozesse können zusätzliche BM anfordern)
Ununterbrechbarkeit (BM eines Prozesses können nicht ohne dessen Zustimmung entzogen werden)
zyklisches Warten (Es muss eine zyklische Kette von Prozessen geben in der jeder Prozess
auf ein BM wartet, das dem nächsten Prozess in der Kette gehört)

Deadlock-Vermeidung:mutual-exclusion (spool-system); belegungsbedingung (preclaiming)
ununterbrechbarkeit:(BM linear ordnen,Anforderungen in aufsteigender Orndung "print>scan>cdBrener")

guter Algorithmus zum wechselseitigen Ausschluss
Korrektheit: immer nur ein Prozess in seinem kritischen Bereich
Fortschritt: Prozesse im nicht-kritischen Bereich dürfen andere Prozess nicht blockieren
Fairness: Alle Prozesse gleich behandelt
Starvation: Kein Prozess darf unendlich lange warten müssen um in seinen kritischen Abschnitt
eintreten zu können

Peterson Algorithmus: setze Marke, unteilbar (atomar)
Sperrvariablen, atomic read-modify-write Instruktionen (TAS-Befehl)
Lockholder-Preemption Problem: Prozessor wird in seinem kritischen Bereich unterbrochen
und anderer Prozessor muss aktiv auf die Freigabe des Spinlocks warten um krit.Bereich zu betreten

Kanal (Kapazität 0, beschränkt, unbeschränkt)
MessageQueues:Kanal für mehrere Sender & mehrere Empfänger(müssen nicht verwandt sein gleichzeitig)

TLB = Translation Lookaside Buffer: Cache für Seitentabellen; typ. 80% Hitrate

Anforderungen Speicherverwaltung:Schutz,Gemeinsame Nutzung(shared memory),Relokation, Organisation
Strategie Speicherallokation: First fit, rotating first fit, best fit, worst fit
Buddy-System: Speicherbereiche immer 2-Potenzen

interne-Fragmentierung: Fragmentierung im belegten Speichersegment selbst
externe-Fragmentierung: Zerstückelung von Freispeicher zwischen belegten Segmenten
Speicherverdichtung(base & bound Register): unbelegte Speicherbereiche verschieben &zusammenfassen
Speicherverwaltung: Swapping,virtueller Speicher
virtueller Speicher (MMU): Paging(1D), Segmentierung(2D)
Paging: Virtueller Speicher in Seiten (Pages) fester Länge unterteilt
Physikalischer Speicher in Seitenrahmen (Page Frames) derselben Länge unterteilt
