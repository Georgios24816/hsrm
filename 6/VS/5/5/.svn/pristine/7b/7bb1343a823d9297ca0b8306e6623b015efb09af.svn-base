/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "hamster.h"
#include "string.h"

CLIENT*  Client;

void hmstr_rpc_init(char* hostname)
{
	Client = clnt_create(hostname, HMSTR_PROG, HMSTR_VERS, "udp");

	if (!Client)
	{
		clnt_pcreateerror(hostname);
		exit(EXIT_FAILURE);
	}
}

void hmstr_rpc_terminate(void)
{
	clnt_destroy(Client);
}

int32_t hmstr_new(const char* owner, const char* hamster, uint16_t treats) 
{
	hmstr_rpc_new_req req;
	hmstr_rpc_new_resp* resp;

	if (owner && hamster)
	{
		memcpy(req.owner_name, owner, 31);
		memcpy(req.hamster_name, hamster, 31);
	}

	req.treats = treats;
	
	resp = hmstr_new_1(&req, Client);

	return resp->uid;
}

int32_t hmstr_lookup(const char* owner_name, const char* hamster_name)
{
	hmstr_rpc_lookup_req req;
	hmstr_rpc_lookup_resp* resp;

	if (owner_name && hamster_name)
	{
		memcpy(req.owner_name, owner_name, 31);
		memcpy(req.hamster_name, hamster_name, 31);
	}

	resp = hmstr_lookup_1(&req, Client);

	return resp->uid;
}

int32_t hmstr_directory(
	int32_t* fdptr,	/**< pointer where to store the open file handle across calls */
	const char* owner_name,		/**< name of hamster's owner */
	const char* hamster_name	/**< name of hamster         */
	)
{
	hmstr_rpc_directory_req req;
	hmstr_rpc_directory_resp* resp;

	printf("START\nhmstr_directory : %d\n", *fdptr);


	//memset(req.owner_name, 0, 32);
	//memset(req.hamster_name, 0, 32);
	//if (owner_name)
	//{
	//	memcpy(req.owner_name, owner_name, strlen(owner_name));
	//}
//
	//if (hamster_name)
	//{
	//	memcpy(req.hamster_name, hamster_name, strlen(hamster_name));
	//}

	req.owner_name = (char*)owner_name;
	req.hamster_name = (char*)hamster_name;
	req.fdptr = *fdptr;

	resp = hmstr_directory_1(&req, Client);
		printf("ownerName : '%s'\n", req.owner_name);
		printf("hamsterName : '%s'\n", req.hamster_name);

	printf("END\nhmstr_directory : %d | %d\n", (int)resp->fdptr, (int)resp->uid);

	return resp->uid;
}

struct hmstr_state
{
	uint16_t treats_left;	/**< How many treats are left in stock? */
	uint32_t rounds;		/**< Number of hamster wheel revolutions */
	int16_t cost;			/**< expenses accumulated so far */
};

int32_t hmstr_howsdoing(
	int32_t ID,
	struct hmstr_state* state
	)
{
	if (!state)
	{
		exit(EXIT_FAILURE);
	}

	hmstr_rpc_howsdoing_req req;
	hmstr_rpc_howsdoing_resp* resp;

	req.ID = ID;
	req.cost = state->cost;
	req.rounds = state->rounds;
	req.treats_left = state->treats_left;

	resp = hmstr_howsdoing_1(&req, Client);

	if (!resp)
	{
		exit(EXIT_FAILURE);
	}

	state->cost = resp->cost;
	state->rounds = resp->rounds;
	state->treats_left = resp->treats_left;

	return resp->zero;
}

int32_t hmstr_readentry(
	int32_t ID,		/**< Hamster's unique ID             */
	char* owner,    /**< Where to store name of Owner    */
	char* name,   	/**< Where to store name of Hamster  */
	int16_t*  price	/**< Where to store cost (up to now) */
	)
{
	hmstr_rpc_readentry_req req;
	hmstr_rpc_readentry_resp* resp;

	memcpy(req.owner_name, owner, 31);
	memcpy(req.hamster_name, name, 31);

	req.ID = ID;
	req.price = *price;

	resp = hmstr_readentry_1(&req, Client);

	return resp->treats;
}

int32_t hmstr_givetreats(
	int32_t ID,	/**< Hamster's unique ID */
	uint16_t treats	/**< How many treats to feed */
	)
{
	hmstr_rpc_givetreats_req req;
	hmstr_rpc_givetreats_resp* resp;

	req.uid = ID;
	req.treats = treats;

	resp = hmstr_givetreats_1(&req, Client);

	return resp->treats;
}

#include <stdio.h>

int hmstr_collect(
	const char *owner_name		/**< name of hamster owner */
	)
{
	hmstr_rpc_collect_req req;
	hmstr_rpc_collect_resp* resp;

	memcpy(req.owner_name, owner_name, 31);

	printf("DEBUG: hmstr_collect: owner_name : '%s'\n", req.owner_name);

	resp = hmstr_collect_1(&req, Client);

	return resp->price;
}

#if 0
void
hmstr_prog_1(char *host)
{
	CLIENT *clnt;
	hmstr_rpc_new_resp  *result_1;
	hmstr_rpc_new_req  hmstr_new_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, HMSTR_PROG, HMSTR_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = hmstr_new_1(&hmstr_new_1_arg, clnt);
	if (result_1 == (hmstr_rpc_new_resp *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	hmstr_prog_1 (host);
exit (0);
}
#endif